// Copyright 2017, Kevin Laeufer <ekiwi@berkeley.edu>

// this file contains the InputType and CoverageType classes that
// are specific to a given module under test
// these will be autogenerated at some point

#ifndef MODULE_INTERFACE_HPP
#define MODULE_INTERFACE_HPP

namespace Test {
using Top = TOP_TYPE;

// this can be autogenerated by sorting the inputs by size and then by
// declaration order
class Input {
protected:
	uint32_t io_in_bits_a;
	uint32_t io_in_bits_b;
	unsigned int reset : 1;
	unsigned int io_in_valid : 1;
	unsigned int io_out_ready : 1;
private:
	unsigned int _padding : 29;
public:
	void apply(Top& top) const {
		top.reset = reset;
		top.io_in_valid = io_in_valid;
		top.io_out_ready = io_out_ready;
		top.io_in_bits_a = io_in_bits_a;
		top.io_in_bits_b = io_in_bits_b;
	}
} __attribute__((packed));
static_assert(sizeof(Input) == 3 * 4, "");

struct Coverage {
protected:
	uint8_t count[11] = {};
private:
	uint8_t _padding[1];
public:
	void update(const Top& top) {
		if (top.io_in_ready) count[0]++;
		if (top.io_out_valid) count[1]++;
		if (top.cov_valid) count[2]++;
		if (top.cov_bits_T_43_true) count[3]++;
		if (top.cov_bits_T_43_false) count[4]++;
		if (top.cov_bits_T_45_true) count[5]++;
		if (top.cov_bits_T_45_false) count[6]++;
		if (top.cov_bits_T_54_true) count[7]++;
		if (top.cov_bits_T_54_false) count[8]++;
		if (top.cov_bits_start_true) count[9]++;
		if (top.cov_bits_start_false) count[10]++;
	}
} __attribute__((packed));
static_assert(sizeof(Coverage) == 3 * 4, "");

} // namespace Test

#endif // MODULE_INTERFACE_HPP
