// Copyright 2018, Kevin Laeufer <laeufer@cs.berkeley.edu>

// this module contains code to load the fuzz configuration TOML
// which is generated by the FIRRTL instrumentation pass
// (and potentially extended/modified by hand)

use toml;
use colored::*;

use std::collections::BTreeMap;
use config::toml::value::Datetime;
use std::fs::File;
use std::io::prelude::*;

use run::TestSize;

pub struct Config {
	size: TestSize,
	data: ConfigData,
}


impl Config {
	pub fn from_file(size: TestSize, filename: &str) -> Self {
		let mut file = File::open(filename).expect("failed to open config");
		let mut contents = String::new();
		file.read_to_string(&mut contents).expect("failed to read config");
		let data: ConfigData = toml::from_str(&contents).unwrap();
		Config { size, data }
	}

	pub fn coverage_count(&self) -> usize {
		// WARN: this assumes that we have an inverted version of every coverage point!
		assert!(self.data.coverage.len() % 2 == 0);
		self.data.coverage.len() / 2
	}

	pub fn print_header(&self) {
		println!("Fuzzing {}", self.data.general.module.bold());
		println!("Instrumented on:   {}", self.data.general.timestamp);
		println!("Coverage Signals:  {}", self.coverage_count());
		println!("Input Fields:      {}", self.data.input.len());
		let width : u64 = self.data.input.values().sum();
		println!("Total Input Width: {}", width);
	}

	pub fn print_inputs(&self, inputs: &[u8]) {
		println!("TODO: print inputs: {:?}", inputs);
	}

	// the coverage map is inverted, i.e., a 0 means covered, a 1 means not covered
	pub fn print_coverage(&self, coverage: &[u8], inverted: bool) {
		println!("TODO: print coverage: {:?}", coverage);
	}
}

#[derive(Debug, Deserialize)]
struct General {
	filename: String,
	instrumented: String,
	module: String,
	timestamp: Datetime
}
#[derive(Debug, Deserialize)]
struct Coverage {
	name: String,
	inverted: bool,
	index: u64,
	counterbits: u64,
	filename: String,
	line: u64,
	column: u64,
	human: String,
}

#[derive(Debug, Deserialize)]
pub struct ConfigData {
	general: General,
	coverage: Vec<Coverage>,
	input: BTreeMap<String, u64>,
}
