// Copyright 2018, Kevin Laeufer <laeufer@cs.berkeley.edu>

// this module contains code to load the fuzz configuration TOML
// which is generated by the FIRRTL instrumentation pass
// (and potentially extended/modified by hand)

use toml;
use config::toml::value::Datetime;
use colored::*;
use prettytable::Table;
use prettytable::row::Row;
use prettytable::cell::Cell;

use std::fs::File;
use std::io::prelude::*;

use run::TestSize;

pub struct Config {
	size: TestSize,
	data: ConfigData,
}

const BITS_PER_COVER_POINT : usize = 2 * 8;

impl Config {
	pub fn from_file(word_size: usize, filename: &str) -> Self {
		let mut file = File::open(filename).expect("failed to open config");
		let mut contents = String::new();
		file.read_to_string(&mut contents).expect("failed to read config");
		let data: ConfigData = toml::from_str(&contents).unwrap();
		let size = Config::determine_test_size(word_size, &data);
		let config = Config { size, data };
		config.validate();
		config
	}

	fn determine_test_size(word_size: usize, data: &ConfigData) -> TestSize {
		let div_2_ceil = |a, b| (a + (b - 1)) / b;
		let to_bytes = |b| div_2_ceil(div_2_ceil(b, 8), word_size) * word_size;

		let input_bits : usize = data.input_bits() as usize;
		let coverage_bits : usize = data.coverage.len() * BITS_PER_COVER_POINT;

		TestSize { input: to_bytes(input_bits), coverage: to_bytes(coverage_bits) }
	}

	fn validate(&self) {
		// make sure the size is large enough to hold coverage and inputs
		let input_bits : usize = self.data.input_bits() as usize;
		assert!(input_bits <= self.size.input * 8);
		let coverage_bits : usize = self.data.coverage.len() * BITS_PER_COVER_POINT;
		assert!(coverage_bits <= self.size.coverage * 8);
	}

	pub fn get_test_size(&self) -> TestSize { self.size }

	pub fn get_inputs(&self) -> Vec<(String,u32)> {
		let mut ii = Vec::with_capacity(self.data.input.len());
		for field in &self.data.input {
			ii.push((field.name.clone(), field.width));
		}
		ii
	}

	pub fn coverage_signal_count(&self) -> usize {
		self.data.coverage.len()
	}

	pub fn print_header(&self) {
		println!("Fuzzing {}", self.data.general.module.bold());
		println!("Instrumented on:   {}", self.data.general.timestamp);
		println!("Coverage Signals:  {}", self.coverage_signal_count());
		println!("Input Fields:      {}", self.data.input.len());
		let width = self.data.input_bits();
		println!("Total Input Width: {}", width);
		println!("Allocated Bytes per Input:    {}", self.size.input);
		println!("Allocated Bytes for Coverage: {}", self.size.coverage);
	}

	pub fn print_inputs(&self, inputs: &[u8]) {
		let cycle_count = inputs.len() / self.size.input;
		assert_eq!(cycle_count * self.size.input, inputs.len());

		// print the inputs as a table! (one row per cycle)
		let mut table = Table::new();

		let mut head_row = vec![Cell::new("C")];
		for field in &self.data.input { head_row.push(Cell::new(&field.name)); }
		table.add_row(Row::new(head_row));

		// bits are labled left to right (the MSB is bit0!)
		let read_bit = |cycle: usize, bit: usize| -> char {
			let byte_ii = cycle * self.size.input + bit / 8;
			let byte = inputs[byte_ii];
			let bit_ii = 7 - (bit % 8);
			let is_set = (byte & (1 << bit_ii)) != 0;
			if is_set { '1' } else { '0' }
		};

		for cycle in 0..cycle_count {
			let mut row = vec![Cell::new(&cycle.to_string())];
			let mut bit = 0;
			for field in &self.data.input {
				let mut bit_str = String::with_capacity(field.width as usize);
				for _ in 0..field.width {
					bit_str.push(read_bit(cycle, bit));
					bit += 1;
				}
				row.push(Cell::new(&bit_str));
			}
			table.add_row(Row::new(row));
		}

		table.printstd();
		//println!("{:?}", inputs)
	}

	// New Config Notes
	// * for individual inputs, the coverage are actual counts
	//  -> display true count + false count
	// * for the bitmap, those counts are bucketed
	//  -> display how many bins are covered, e.g. `7/8`
	//  -> display which bins are covered, e.g. `00100101`
	//
	// ==> thus we should probably split this function into two for now
	//     instead of using the "inverted flag"

	// to be run on the raw coverage feedback from the fuzz server
	pub fn print_test_coverage(&self, coverage: &[u8]) {
		assert_eq!(coverage.len(), self.size.coverage);

		let mut table = Table::new();
		table.add_row(row!["True", "False", "name", "expression", "source location"]);

		for cov in self.data.coverage.iter() {
			let byte_ii = (cov.index * 2) as usize;
			let count_true = coverage[byte_ii];
			let count_false = coverage[byte_ii+1];
			let src = format!("{}:{}", cov.filename, cov.line);
			table.add_row(row![count_true, count_false, cov.name, cov.human, src]);
		}
		table.printstd();
	}

	// to be run on the binned coverage bitmap
	pub fn print_bitmap(&self, bitmap: &[u8]) {
		assert_eq!(bitmap.len(), self.size.coverage);

		let mut table = Table::new();
		table.add_row(row!["#T", "T", "#F", "F", "name", "expression", "source location"]);

		for cov in self.data.coverage.iter() {
			let byte_ii = (cov.index * 2) as usize;
			let covd_true = bitmap[byte_ii];
			let covd_false = bitmap[byte_ii+1];

			let num_true = format!("{}/8", covd_true.count_zeros());
			let bits_true = format!("{:b}", covd_true);
			let num_false = format!("{}/8", covd_false.count_zeros());
			let bits_false = format!("{:b}", covd_false);

			let src = format!("{}:{}", cov.filename, cov.line);
			table.add_row(row![num_true, bits_true, num_false, bits_false, cov.name, cov.human, src]);
		}
		table.printstd();
	}
}

#[derive(Debug, Deserialize)]
struct General {
	filename: String,
	instrumented: String,
	module: String,
	timestamp: Datetime
}
#[derive(Debug, Deserialize)]
struct Coverage {
	name: String,
	index: i32,
	filename: String,
	line: i32,
	column: i32,
	human: String,
}
#[derive(Debug, Deserialize)]
struct Input {
	name: String,
	width: u32,
}


#[derive(Debug, Deserialize)]
pub struct ConfigData {
	general: General,
	coverage: Vec<Coverage>,
	input: Vec<Input>,
}

impl ConfigData {
	fn input_bits(&self) -> u32 {
		self.input.iter().map(|ii| ii.width).sum::<u32>()
	}
}
