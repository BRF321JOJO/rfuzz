
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <cstdint>
#include <cassert>
#include <algorithm>
#include <verilated.h>

#if VM_TRACE
# include <verilated_vcd_c.h>	// Trace file format header
#endif

// Override Verilator definition so first $finish ends simulation
// Note: VL_USER_FINISH needs to be defined when compiling Verilator code
void vl_finish(const char* filename, int linenum, const char* hier) {
  Verilated::flushCall();
  exit(0);
}

using namespace std;

// this can be autogenerated by sorting the inputs by size and then by
// declaration order
struct Input {
	uint32_t io_in_bits_a;
	uint32_t io_in_bits_b;
	unsigned int reset : 1;
	unsigned int io_in_valid : 1;
	unsigned int io_out_ready : 1;
} __attribute__((packed));
static_assert(sizeof(Input) == 9);

static constexpr size_t BUFFER_SIZE = 64 * 1024;
char input_buffer[BUFFER_SIZE];

vector<Input> readInput() {
	cin.read(input_buffer, BUFFER_SIZE);
	const auto len = cin.gcount();
	const auto input_count = len / sizeof(Input);
	cout << "input_count: " << input_count << endl;
	auto items = reinterpret_cast<const Input*>(input_buffer);
	vector<Input> inputs;
	for(int ii = 0; ii < input_count; ii++) {
		inputs.push_back(items[ii]);
	}
	return inputs;
}

Vgcdcov *top;

vluint64_t main_time = 0;       // Current simulation time
        // This is a 64-bit integer to reduce wrap over issues and
        // allow modulus.  You can also use a double, if you wish.

double sc_time_stamp () { // Called by $time in Verilog
  return main_time;       // converts to double, to match
                          // what SystemC does
}

const long timeout = 10000L;

int main(int argc, char** argv) {
  afl_init();
  cout << "Hello World!" << endl;

  // Read inputs
  vector<Input> inputs = readInput();
  vector<Input>::iterator inputs_it = inputs.begin();

  Verilated::commandArgs(argc, argv);
  top = new TOP_TYPE;

#if VM_TRACE			// If verilator was invoked with --trace
    Verilated::traceEverOn(true);	// Verilator must compute traced signals
    VL_PRINTF("Enabling waves...\n");
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace (tfp, 99);	// Trace 99 levels of hierarchy
    tfp->open ("dump.vcd");	// Open the dump file
#endif

  top->reset = 1;

  cout << "Starting simulation!\n";

  while (!Verilated::gotFinish() && main_time < timeout && inputs_it != inputs.end()) {
    if ((main_time % 10) == 1) {
      top->clock = 1;       // Toggle clock
    }
    // Read coverage here
    if ((main_time % 10) == 2) {
      if (top->io_in_ready) afl_increment(0);
      if (top->io_out_valid) afl_increment(1);
      if (top->cov_valid) afl_increment(2);
      if (top->cov_bits_T_43_true) afl_increment(3);
      if (top->cov_bits_T_43_false) afl_increment(4);
      if (top->cov_bits_T_45_true) afl_increment(5);
      if (top->cov_bits_T_45_false) afl_increment(6);
      if (top->cov_bits_T_54_true) afl_increment(7);
      if (top->cov_bits_T_54_false) afl_increment(8);
      if (top->cov_bits_start_true) afl_increment(9);
      if (top->cov_bits_start_false) afl_increment(10);
    }
    if ((main_time % 10) == 6) {
      top->clock = 0;
      top->reset = inputs_it->reset;
      top->io_in_valid = inputs_it->io_in_valid;
      top->io_out_ready = inputs_it->io_out_ready;
      top->io_in_bits_a = inputs_it->io_in_bits_a;
      top->io_in_bits_b = inputs_it->io_in_bits_b;
      inputs_it++;
    }
    top->eval();               // Evaluate model
#if VM_TRACE
	if (tfp) tfp->dump (main_time);	// Create waveform trace for this timestamp
#endif
    main_time++;               // Time passes...
  }

  if (main_time >= timeout) {
      cout << "Assertion failed! Simulation terminated by timeout at time " << main_time <<
              " (cycle " << main_time / 10 << ")"<< endl;
      return -1;
  } else {
      cout << "Simulation completed at time " << main_time <<
              " (cycle " << main_time / 10 << ")"<< endl;
  }

  // Run for 10 more clocks
  vluint64_t end_time = main_time + 100;
  while (main_time < end_time) {
    if ((main_time % 10) == 1) {
      top->clock = 1;       // Toggle clock
    }
    if ((main_time % 10) == 6) {
      top->clock = 0;
    }
    top->eval();               // Evaluate model
#if VM_TRACE
	if (tfp) tfp->dump (main_time);	// Create waveform trace for this timestamp
#endif
    main_time++;               // Time passes...
  }

#if VM_TRACE
    if (tfp) tfp->close();
#endif
}

